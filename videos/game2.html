<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Backrooms Escape - Enhanced Realism</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', monospace;
            cursor: none;
        }
        
        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ff88;
            font-size: 16px;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.7);
            z-index: 10;
            pointer-events: none;
            background: rgba(0, 15, 5, 0.5);
            backdrop-filter: blur(5px);
            padding: 15px;
            border: 1px solid rgba(0, 255, 136, 0.2);
            border-radius: 5px;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.1);
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 2px;
            height: 2px;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 50%;
            box-shadow: 0 0 5px rgba(255,255,255,0.5);
            pointer-events: none;
            z-index: 5;
        }
        
        #instructions {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            text-align: center;
            z-index: 10;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 20px;
            border-radius: 5px;
        }
        
        #warning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff0000;
            font-size: 42px;
            text-align: center;
            opacity: 0;
            text-shadow: 0 0 20px #ff0000;
            z-index: 15;
            pointer-events: none;
            font-weight: bold;
        }
        
        #eventText {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            color: #ffaa00;
            font-size: 24px;
            text-align: center;
            opacity: 0;
            text-shadow: 0 0 15px rgba(255, 170, 0, 0.8);
            z-index: 15;
            pointer-events: none;
            transition: opacity 0.5s;
        }

        #dialogueBox {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            color: #00eaff;
            font-size: 18px;
            text-align: center;
            z-index: 10;
            pointer-events: none;
            background: rgba(0, 20, 30, 0.7);
            padding: 15px 25px;
            border-radius: 5px;
            border: 1px solid rgba(0, 234, 255, 0.5);
            text-shadow: 0 0 10px #00eaff;
            opacity: 0;
            transition: opacity 0.5s;
            max-width: 80%;
        }
        
        .scanline {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.05),
                rgba(0, 0, 0, 0.05) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 20;
            opacity: 0.2;
        }

        .vignette {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            box-shadow: inset 0 0 200px rgba(0,0,0,0.8);
            pointer-events: none;
            z-index: 19;
        }

        #ammoBar {
            margin-top: 10px;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 4px;
            overflow: hidden;
        }

        #ammoFill {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #00aa55);
            width: 100%;
            transition: width 0.2s;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="scanline"></div>
    <div class="vignette"></div>
    <div id="crosshair"></div>
    
    <div id="ui">
        <div>SANITY: <span id="sanity">100</span>%</div>
        <div>LEVEL: <span id="level">0</span></div>
        <div>KILLS: <span id="kills">0</span></div>
        <div>COLLECTED: <span id="collected">0</span></div>
        <div id="ammoDisplay">AMMO: <span id="ammo">30</span> / âˆž</div>
        <div id="ammoBar"><div id="ammoFill"></div></div>
        <div style="margin-top: 8px; font-size: 12px; opacity: 0.7;">SHADER: <span id="shaderMode">NORMAL</span></div>
    </div>
    
    <div id="instructions">
        WASD-Move | MOUSE-Look | CLICK-Attack | R-Reload | 1-Gun | 2-Sword | 3-Tentacle | 5-Shotgun | TAB-Cycle Shaders | Find EXIT
    </div>
    
    <div id="warning">THEY ARE WATCHING YOU</div>
    <div id="eventText"></div>
    <div id="dialogueBox"></div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/SkeletonUtils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/Pass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

    <script>
      window.onload = function() {
        const canvas = document.getElementById('canvas');
        
        // Scene setup
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x0a0a0a, 1, 40);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 400);
        camera.position.set(0, 1.6, 0);
        
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio || 1);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;

        // Post-processing
        const composer = new THREE.EffectComposer(renderer);
        const renderPass = new THREE.RenderPass(scene, camera);
        composer.addPass(renderPass);
        const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0;
        bloomPass.strength = 0.5;
        bloomPass.radius = 0;
        composer.addPass(bloomPass);
        
        // Game state
        let gameState = {
            sanity: 1.0, level: 0, kills: 0, moveSpeed: 0.12,
            entities: [], projectiles: [], exitPortal: null, morphoser: null,
            keys: {}, rotation: { x: 0, y: 0 }, isLocked: false,
            ammo: 30, maxAmmo: 30, reloading: false, lastShot: 0,
            shaderMode: 0, eventTimer: 0, activeEvent: null, maze: null,
            lastStepTime: 0, activeWeapon: 'gun', sword: null, shotgun: null,
            railgun: null, tentacle: null, pistol: null, isSwinging: false, swingStartTime: 0,
            isWhipping: false, whipStartTime: 0, flickeringLights: [],
            recoil: 0, lastRecoilTime: 0,
            chunks: {}, chunkSize: 60, chunkRadius: 2,
            collected: 0
        };

        const shaderModes = ['NORMAL', 'CREEPY', 'CRIMSON', 'VOID', 'GLITCH', 'RAGE', 'RAINBOW', 'WATER'];

        let zombieModel = null;
        let zombieAnimations = [];
        let floorTexture = null;
        let mainLight;

        const loadingManager = new THREE.LoadingManager();
        const gltfLoader = new THREE.GLTFLoader(loadingManager);
        const textureLoader = new THREE.TextureLoader(loadingManager);

        floorTexture = textureLoader.load('../assets/textures/floor.png', (tex) => { tex.wrapS = tex.wrapT = THREE.RepeatWrapping; });

        gltfLoader.load('../assets/models/zombie.glb', (gltf) => {
            zombieModel = gltf.scene;
            zombieAnimations = gltf.animations;
            console.log("Zombie model loaded.");
        });

        gltfLoader.load('../assets/models/pistol.glb', (gltf) => {
            gameState.pistol = gltf.scene;
            gameState.pistol.scale.set(0.1, 0.1, 0.1);
            gameState.pistol.position.set(0.3, -0.3, -0.5);
            gameState.pistol.rotation.y = Math.PI;
            camera.add(gameState.pistol);
            gameState.pistol.visible = (gameState.activeWeapon === 'gun');
            console.log("Pistol model loaded for weapon switching.");
        });

        gltfLoader.load('../assets/models/rifle.glb', (gltf) => {
            gameState.rifle = gltf.scene;
            gameState.rifle.scale.set(0.1, 0.1, 0.1);
            gameState.rifle.position.set(0.3, -0.3, -0.5);
            gameState.rifle.rotation.y = Math.PI;
            camera.add(gameState.rifle);
            gameState.rifle.visible = false; // Initially hidden
            console.log("Rifle model loaded.");
        });

        loadingManager.onLoad = () => {
            console.log("All assets loaded, starting game.");
            initGame();
            animate();
        };

        const AudioEngine = {
            ctx: null, isInitialized: false, masterGain: null,
            ambientSource: null, ambientGain: null, ambientBuffer: null,

            init() {
                if (this.isInitialized) return;
                try {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    this.ctx.resume();
                    this.masterGain = this.ctx.createGain();
                    this.masterGain.gain.setValueAtTime(0.3, this.ctx.currentTime);
                    this.masterGain.connect(this.ctx.destination);
                    this.isInitialized = true;
                    console.log("Audio Engine Initialized.");
                    this.loadAmbientSound('../assets/sounds/ambient.wav');
                } catch (e) { console.error("Web Audio API is not supported in this browser", e); }
            },
            loadAmbientSound(url) {
                if (!this.isInitialized) return;
                const request = new XMLHttpRequest();
                request.open('GET', url, true);
                request.responseType = 'arraybuffer';
                const self = this;

                request.onload = function() {
                    if (request.status === 200) {
                        self.ctx.decodeAudioData(request.response, function(buffer) {
                            self.ambientBuffer = buffer;
                            console.log("Ambient sound loaded successfully: " + url);
                            self._playAmbient();
                        }, function(e) { 
                            console.error("Error decoding audio data for " + url, e); 
                        });
                    } else {
                        console.error('Failed to load sound file. Status: ' + request.status + ' for ' + url);
                    }
                };

                request.onerror = function() {
                    console.error('Network error occurred while trying to fetch sound: ' + url);
                };
                
                request.send();
            },
            speak(text, options, onEndCallback) {
                if (typeof options === 'function') { onEndCallback = options; options = {}; }
                options = options || {};
                if (!('speechSynthesis' in window) || window.speechSynthesis.speaking) {
                    if(onEndCallback) onEndCallback(); return;
                }
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.pitch = (typeof options.pitch === 'number') ? options.pitch : 0.95;
                utterance.rate = (typeof options.rate === 'number') ? options.rate : 0.95;
                utterance.volume = (typeof options.volume === 'number') ? options.volume : 1.0;
                const voices = window.speechSynthesis.getVoices();
                if (options.voice) {
                    utterance.voice = voices.find(voice => voice.name === options.voice) || utterance.voice;
                } else if (options.preferDeep) {
                    utterance.voice = voices.find(v => /male|david|daniel|alex|mark|john/i.test(v.name)) || voices.find(v => /en/i.test(v.lang)) || utterance.voice;
                } else if (options.preferSoft) {
                    utterance.voice = voices.find(v => /female|susan|katherine|zira|alloy/i.test(v.name)) || voices.find(v => /en/i.test(v.lang)) || utterance.voice;
                }
                utterance.onend = onEndCallback;
                try { window.speechSynthesis.speak(utterance); }
                catch (e) { if(onEndCallback) onEndCallback(); }
            },
            speakFriendly(text, onEndCallback) {
                this.speak(text, { pitch: 1.05, rate: 1.0, volume: 1.0, preferSoft: true }, onEndCallback);
            },
            speakEnemy(text, onEndCallback) {
                if (this.isInitialized) this._play(this.sounds.enemyGrowl);
                this.speak(text, { pitch: 0.45, rate: 0.9, volume: 1.0, preferDeep: true }, onEndCallback);
            },
            _play(sound) { if (!this.isInitialized) return; sound(this.ctx, this.masterGain); },
            _playAmbient() {
                if (!this.isInitialized || !this.ambientBuffer || this.ambientSource) return;
                const ctx = this.ctx;
                this.ambientSource = ctx.createBufferSource();
                this.ambientSource.buffer = this.ambientBuffer;
                this.ambientSource.loop = true;
                this.ambientGain = ctx.createGain();
                this.ambientGain.gain.setValueAtTime(0.1, ctx.currentTime);
                this.ambientSource.connect(this.ambientGain);
                this.ambientGain.connect(this.masterGain);
                this.ambientSource.start(0);
                console.log("Playing ambient sound.");
            },
            updateSanityEffect(sanity) {
                if (!this.isInitialized || !this.ambientSource || !this.ambientGain) return;
                const playbackRate = 0.8 + sanity * 0.2;
                const gain = 0.05 + sanity * 0.05;
                this.ambientSource.playbackRate.linearRampToValueAtTime(playbackRate, this.ctx.currentTime + 0.5);
                this.ambientGain.gain.linearRampToValueAtTime(gain, this.ctx.currentTime + 0.5);
            },
            sounds: {
                shoot: (ctx, dest) => { const o = ctx.createOscillator(), g = ctx.createGain(); o.connect(g); g.connect(dest); o.type = 'triangle'; o.frequency.setValueAtTime(880, ctx.currentTime); o.frequency.exponentialRampToValueAtTime(220, ctx.currentTime + 0.1); g.gain.setValueAtTime(0.5, ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.15); o.start(ctx.currentTime); o.stop(ctx.currentTime + 0.2); },
                swordSwing: (ctx, dest) => { const n = ctx.createBufferSource(), bs = ctx.sampleRate * 0.3, b = ctx.createBuffer(1, bs, ctx.sampleRate), d = b.getChannelData(0); for (let i = 0; i < bs; i++) d[i] = Math.random() * 2 - 1; n.buffer = b; const bp = ctx.createBiquadFilter(); bp.type = 'bandpass'; bp.frequency.setValueAtTime(1500, ctx.currentTime); bp.frequency.exponentialRampToValueAtTime(500, ctx.currentTime + 0.3); bp.Q.value = 5; const g = ctx.createGain(); g.gain.setValueAtTime(0.6, ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.3); n.connect(bp); bp.connect(g); g.connect(dest); n.start(ctx.currentTime); n.stop(ctx.currentTime + 0.3); },
                tentacleWhip: (ctx, dest) => { const o = ctx.createOscillator(), g = ctx.createGain(); o.connect(g); g.connect(dest); o.type = 'sawtooth'; o.frequency.setValueAtTime(100, ctx.currentTime); o.frequency.exponentialRampToValueAtTime(400, ctx.currentTime + 0.1); g.gain.setValueAtTime(0.4, ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.2); o.start(ctx.currentTime); o.stop(ctx.currentTime + 0.2); },
                walk: (ctx, dest) => { const n = ctx.createBufferSource(), bs = ctx.sampleRate * 0.1, b = ctx.createBuffer(1, bs, ctx.sampleRate); let d = b.getChannelData(0); for (let i = 0; i < bs; i++) d[i] = Math.random() * 2 - 1; n.buffer = b; const f = ctx.createBiquadFilter(); f.type = 'lowpass'; f.frequency.setValueAtTime(300, ctx.currentTime); const g = ctx.createGain(); g.gain.setValueAtTime(0.2, ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.1); n.connect(f); f.connect(g); g.connect(dest); n.start(ctx.currentTime); n.stop(ctx.currentTime + 0.1); },
                reload: (ctx, dest) => { const c = (f, d) => { setTimeout(() => { if (!ctx || ctx.state === 'closed') return; const o = ctx.createOscillator(), g = ctx.createGain(); o.connect(g); g.connect(dest); o.type = 'square'; o.frequency.setValueAtTime(f, ctx.currentTime); g.gain.setValueAtTime(0.1, ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.05); o.start(ctx.currentTime); o.stop(ctx.currentTime + 0.05); }, d); }; c(1500, 0); c(1200, 150); },
                entityHit: (ctx, dest) => { const o = ctx.createOscillator(), g = ctx.createGain(); o.connect(g); g.connect(dest); o.type = 'sawtooth'; o.frequency.setValueAtTime(200, ctx.currentTime); o.frequency.exponentialRampToValueAtTime(50, ctx.currentTime + 0.2); g.gain.setValueAtTime(0.3, ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.2); o.start(ctx.currentTime); o.stop(ctx.currentTime + 0.2); },
                railgun: (ctx, destination) => { const o = ctx.createOscillator(), g = ctx.createGain(); o.type = 'sawtooth'; o.frequency.setValueAtTime(2000, ctx.currentTime); o.frequency.exponentialRampToValueAtTime(100, ctx.currentTime + 0.1); g.gain.setValueAtTime(0.4, ctx.currentTime); g.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.5); o.connect(g); g.connect(destination); o.start(); o.stop(ctx.currentTime + 0.5); },
                nextLevel: (ctx, dest) => { [261.63, 329.63, 392.00, 523.25].forEach((f, i) => { const o = ctx.createOscillator(), g = ctx.createGain(); o.connect(g); g.connect(dest); o.type = 'sine'; o.frequency.setValueAtTime(f, ctx.currentTime + i * 0.1); g.gain.setValueAtTime(0.3, ctx.currentTime + i * 0.1); g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + i * 0.1 + 0.1); o.start(ctx.currentTime + i * 0.1); o.stop(ctx.currentTime + i * 0.1 + 0.15); }); },
                pickup: (ctx, dest) => { const o = ctx.createOscillator(), g = ctx.createGain(); o.connect(g); g.connect(dest); o.type = 'sine'; o.frequency.setValueAtTime(880, ctx.currentTime); o.frequency.exponentialRampToValueAtTime(440, ctx.currentTime + 0.15); g.gain.setValueAtTime(0.15, ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.2); o.start(ctx.currentTime); o.stop(ctx.currentTime + 0.2); },
                enemyGrowl: (ctx, dest) => { const o = ctx.createOscillator(), g = ctx.createGain(), lf = ctx.createOscillator(); o.type = 'sine'; o.frequency.setValueAtTime(60, ctx.currentTime); lf.type = 'sine'; lf.frequency.setValueAtTime(0.8, ctx.currentTime); const shaper = ctx.createWaveShaper(), curve = new Float32Array(256); for (let i = 0; i < 256; i++) { const x = i * 2 / 256 - 1; curve[i] = Math.tanh(x * 2); } shaper.curve = curve; shaper.oversample = '2x'; lf.connect(g.gain); o.connect(shaper); shaper.connect(g); g.connect(dest); g.gain.setValueAtTime(0.001, ctx.currentTime); g.gain.linearRampToValueAtTime(0.35, ctx.currentTime + 0.02); g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 1.0); o.start(ctx.currentTime); lf.start(ctx.currentTime); o.stop(ctx.currentTime + 1.0); lf.stop(ctx.currentTime + 1.0); },
            },
            play(soundName) { if (!this.isInitialized || !this.sounds[soundName]) return; this._play(this.sounds[soundName]); }
        };
        
        const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x999999, roughness: 0.8, metalness: 0.2 });

        const skyMaterial = new THREE.ShaderMaterial({
            side: THREE.BackSide,
            depthWrite: false,
            uniforms: { time: { value: 0 }, baseTop: { value: new THREE.Color(0x0b1230) }, baseBottom: { value: new THREE.Color(0x00101a) }, nebulaA: { value: new THREE.Color(0xff5aa8) }, nebulaB: { value: new THREE.Color(0x5b3bff) }, accentA: { value: new THREE.Color(0x00ffe1) }, accentB: { value: new THREE.Color(0xffcc66) }, starColor: { value: new THREE.Color(0xffffff) }, starDensity: { value: 1.0 }, nebulaDetail: { value: 1.0 }, flowStrength: { value: 1.6 }, speed: { value: 0.3 }, cometSeed: { value: Math.random() * 1000.0 } },
            vertexShader: `varying vec3 vPos; void main(){ vPos = normalize(position); gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }`,
            fragmentShader: `precision highp float; varying vec3 vPos; uniform float time; uniform float speed; uniform float flowStrength; uniform float nebulaDetail; uniform float cometSeed; uniform vec3 baseTop; uniform vec3 baseBottom; uniform vec3 nebulaA; uniform vec3 nebulaB; uniform vec3 accentA; uniform vec3 accentB; uniform vec3 starColor; uniform float starDensity; float hash2(vec2 p) { return fract(sin(dot(p, vec2(127.1,311.7))) * 43758.5453123); } float fbm3(vec3 p) { float amp = 0.5; float sum = 0.0; for(int i=0;i<6;i++){ sum += amp * fract(sin(dot(p, vec3(127.1,311.7, 74.7) * float(i+1))) * 43758.5453); p *= 2.0; amp *= 0.5; } return sum; } vec3 curl(vec3 p) { float e = 0.01; float a = fbm3(p); float bx = fbm3(p + vec3(e, 0.0, 0.0)); float by = fbm3(p + vec3(0.0, e, 0.0)); float bz = fbm3(p + vec3(0.0, 0.0, e)); return normalize(vec3(by - bz, bz - bx, bx - by)); } vec3 nebulaPalette(float t) { return mix(nebulaA, nebulaB, smoothstep(0.0,1.0,t)); } float comet(vec2 uv, vec2 center, vec2 dir, float length, float thickness) { vec2 rel = uv - center; float proj = dot(rel, dir); float side = dot(rel, vec2(-dir.y, dir.x)); float t = smoothstep(0.0, 1.0, proj / length); float line = exp(-pow(side / (thickness * (1.0 - t*0.8) + 0.0001), 2.0) * 4.0); line *= (1.0 - smoothstep(0.0, 1.0, proj / length)); return line * (0.6 + 0.4 * (1.0 - t)); } void main(){ vec3 dir = normalize(vPos); float up = smoothstep(-0.3, 1.0, dir.y); vec3 base = mix(baseBottom, baseTop, up); vec2 sph = vec2(atan(dir.z, dir.x), asin(dir.y)); vec3 p = vec3(dir * 2.0); vec3 flow = curl(p * 0.7 + time * 0.12) * flowStrength; float density = 0.0; float scl = 1.0; for(int i=0;i<5;i++){ float v = fbm3((p + flow * float(i) * 0.18 + vec3(time * 0.06 * float(i))) * scl); v = smoothstep(0.18, 0.75, v); density += v * (0.55 / float(i + 1)); scl *= 1.9; } density = clamp(density * nebulaDetail, 0.0, 1.0); vec3 neb = nebulaPalette(density) * density * 1.6; vec3 accents = mix(accentA, accentB, fract(density * 1.3)) * density * 0.9; vec3 color = base + neb + accents; float rim = pow(max(0.0, 1.0 - abs(dir.y - 0.22) * 3.0), 2.2); color += vec3(0.12, 0.06, 0.18) * rim * 1.4; vec2 uv = vec2(sph.x / 6.2831853 + 0.5, sph.y / 3.14159 + 0.5); float micro = pow(max(0.0, 1.0 - length(fract(uv * 8192.0) - 0.5) * 2.0), 40.0); float tw = 0.5 + 0.5 * sin(time * 6.0 + hash2(uv) * 50.0); float starsSmall = micro * tw * starDensity * 0.9; float cluster = pow(fbm3(vec3(uv * 80.0, time * 0.02)), 6.0) * 0.9 * starDensity; float stars = clamp(starsSmall + cluster, 0.0, 1.0); color += starColor * stars * 1.8; float cometSum = 0.0; for(int i = 0; i < 3; i++){ float ci = float(i); float seed = fract(sin(cometSeed + ci * 12.9898) * 43758.5453); float speedOff = 0.02 + seed * 0.06; vec2 center = vec2(fract(seed * 7.0 + time * speedOff), fract(seed * 13.0 - time * speedOff * 0.4)); float a = seed * 6.28318; vec2 dir2 = normalize(vec2(cos(a*1.3), sin(a*0.9))); float len = 0.25 + seed * 0.6; cometSum += comet(uv, center, dir2, len, 0.002 + seed * 0.01) * (0.6 + seed * 0.8); } color += vec3(1.0,0.9,0.7) * cometSum * 1.5; color = pow(color, vec3(0.92)); color = mix(color, vec3(dot(color, vec3(0.3,0.59,0.11))), 0.02); gl_FragColor = vec4(color, 1.0); }`
        });
        const skyGeo = new THREE.SphereGeometry(300, 56, 56);
        const sky = new THREE.Mesh(skyGeo, skyMaterial);
        scene.add(sky);
        
        function seededRandom(cx, cz, salt = 1234567) { let n = (cx * 374761393) ^ (cz * 668265263) ^ salt; n = (n ^ (n >>> 13)) >>> 0; return (n % 10000) / 10000; }

        function createChunk(cx, cz) {
            const group = new THREE.Group();
            const chunkSize = gameState.chunkSize;
            group.position.set(cx * chunkSize, 0, cz * chunkSize);

            const floorMaterial = new THREE.MeshStandardMaterial({ map: floorTexture });
            floorMaterial.map.repeat.set(4, 4);
            const floorGeo = new THREE.PlaneGeometry(chunkSize, chunkSize);
            const floor = new THREE.Mesh(floorGeo, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            floor.position.y = 0;
            group.add(floor);

            const ceilingMaterial = new THREE.MeshStandardMaterial({ color: 0x202020, roughness: 0.95 });
            const ceiling = new THREE.Mesh(floorGeo, ceilingMaterial);
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.y = 4;
            group.add(ceiling);

            const step = 12;
            gameState.flickeringLights = gameState.flickeringLights || [];
            group.userData.collectibles = [];
            group.userData.props = [];
            for (let ox = -chunkSize/2; ox < chunkSize/2; ox += step) {
                for (let oz = -chunkSize/2; oz < chunkSize/2; oz += step) {
                    const r = seededRandom(cx + Math.floor(ox), cz + Math.floor(oz));
                    if (r > 0.8) {
                        const w = 2 + seededRandom(cx + ox, cz + oz, 3) * (step - 4);
                        const d = 2 + seededRandom(cx + oz, cz + ox, 4) * (step - 4);
                        const h = 4 + Math.floor(seededRandom(cx + oz, cz + ox) * 8);
                        const wallGeo = new THREE.BoxGeometry(w, h, d);
                        const wall = new THREE.Mesh(wallGeo, wallMaterial);
                        const xPos = ox + (seededRandom(cx + ox, cz + oz, 1) - 0.5) * (step - w);
                        const zPos = oz + (seededRandom(cz + oz, cx + ox, 2) - 0.5) * (step - d);
                        wall.position.set(xPos, h / 2, zPos);
                        wall.rotation.y = (seededRandom(ox, oz) - 0.5) * Math.PI * 0.25;
                        wall.castShadow = true;
                        group.add(wall);
                    }
                    if (seededRandom(cx+ox*7, cz+oz*11) > 0.98) {
                        const light = new THREE.PointLight(0xffee88, 0, 10, 2);
                        light.position.set(ox, 3.5, oz);
                        light.castShadow = false;
                        group.add(light);
                        gameState.flickeringLights.push(light);
                    }
                    if (seededRandom(cx*3+ox, cz*5+oz) > 0.995) {
                        const ent = createEntity(group.position.x + ox + seededRandom(ox,oz)*2, group.position.z + oz + seededRandom(oz,ox)*2, Math.floor(seededRandom(ox,oz)*3));
                        gameState.entities.push(ent);
                        group.add(ent);
                    }
                    const pr = seededRandom(cx*7+ox, cz*13+oz);
                    if (pr > 0.97 && pr < 0.995) {
                        let prop;
                        if (pr > 0.985) {
                            prop = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.6, 3, 12), new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.9 }));
                            prop.position.set(ox, 1.5, oz);
                        } else {
                            prop = new THREE.Mesh(new THREE.BoxGeometry(1.2,1.2,1.2), new THREE.MeshStandardMaterial({ color: 0x775533, roughness: 0.8 }));
                            prop.position.set(ox, 0.6, oz);
                        }
                        prop.castShadow = true; prop.receiveShadow = true;
                        group.add(prop);
                        group.userData.props.push(prop);
                    }
                    if (seededRandom(cx*11+ox, cz*17+oz) > 0.997) {
                        const orbGeo = new THREE.SphereGeometry(0.25, 8, 8);
                        const orbMat = new THREE.MeshStandardMaterial({ color: 0xffff88, emissive: 0xffff66, emissiveIntensity: 1.5, metalness: 0.2 });
                        const orb = new THREE.Mesh(orbGeo, orbMat);
                        orb.position.set(ox + seededRandom(ox,oz)*0.5, 1.0 + seededRandom(ox+1,oz+1)*0.5, oz + seededRandom(oz,ox)*0.5);
                        orb.userData.collectible = true;
                        orb.userData.collected = false;
                        group.add(orb);
                        group.userData.collectibles.push(orb);
                    }
                }
            }
            if (seededRandom(cx, cz) > 0.995) {
                const landmark = new THREE.Mesh(new THREE.ConeGeometry(2, 6, 8), new THREE.MeshStandardMaterial({ color: 0x8800ff, emissive: 0x440044 }));
                landmark.position.set(0, 3, 0);
                group.add(landmark);
            }
            group.userData = { cx, cz };
            return group;
        }

        function updateChunks(centerPos) {
            const cx = Math.floor(centerPos.x / gameState.chunkSize);
            const cz = Math.floor(centerPos.z / gameState.chunkSize);
            const radius = gameState.chunkRadius;
            const needed = {};
            for (let x = cx - radius; x <= cx + radius; x++) {
                for (let z = cz - radius; z <= cz + radius; z++) {
                    const key = x + ',' + z;
                    needed[key] = true;
                    if (!gameState.chunks[key]) {
                        const ch = createChunk(x, z);
                        gameState.chunks[key] = ch;
                        scene.add(ch);
                    }
                }
            }
            Object.keys(gameState.chunks).forEach(k => {
                if (!needed[k]) {
                    const ch = gameState.chunks[k];
                    ch.traverse(child => {
                        if (child.userData && child.userData.type !== undefined) {
                            gameState.entities = gameState.entities.filter(e => e !== child);
                        }
                        if (child.isPointLight) {
                            gameState.flickeringLights = (gameState.flickeringLights || []).filter(l => l !== child);
                        }
                        if (child.geometry) { child.geometry.dispose(); }
                        if (child.material) { if (Array.isArray(child.material)) child.material.forEach(m=>m.dispose()); else child.material.dispose(); }
                    });
                    if (ch.userData && ch.userData.props) {
                        ch.userData.props.forEach(p => { if (p.geometry) p.geometry.dispose(); if (p.material) p.material.dispose(); });
                    }
                    if (ch.userData && ch.userData.collectibles) {
                        ch.userData.collectibles.forEach(c => { if (c.parent) c.parent.remove(c); });
                    }
                    scene.remove(ch);
                    delete gameState.chunks[k];
                }
            });
        }

        function regenerateWorld() {
            Object.keys(gameState.chunks || {}).forEach(k => { scene.remove(gameState.chunks[k]); delete gameState.chunks[k]; });
            updateChunks(camera.position);
        }
        
        function createEntity(x, z, type = 0) {
            const types = [
                { color: 0x330000, emissive: 0xff0000, speed: 0.01, health: 3, size: 0.8, isFriendly: false, dialogue: {normal: ["We are one.", "You cannot comprehend.", "The pattern must be completed.", "Your presence is a flaw."]} },
                { color: 0x001a33, emissive: 0x0088ff, speed: 0.02, health: 2, size: 0.6, isFriendly: false, dialogue: {normal: ["It is listening.", "The frequency is changing.", "You disrupt the signal.", "Become one with the static."]} },
                { color: 0x1a3300, emissive: 0x88ff00, speed: 0.0075, health: 5, size: 1.2, isFriendly: false, dialogue: {normal: ["The flesh is weak.", "We will consume.", "Your form is imperfect.", "Join the growth."]} },
                { color: 0x003333, emissive: 0x00ffff, speed: 0.01, health: 100, size: 0.7, isFriendly: true, dialogue: { highSanity: ["You seem lucid. Good.", "The exit is real, but it moves.", "These walls... they listen.", "I saw a man with a face like a clock.", "The yellow is a lie.", "Stay away from the shadows, they bite.", "The architect of this place is a madman.", "I've seen others, but they all go mad."], lowSanity: ["...the colors... they scream...", "It sees you. It knows your name.", "You're becoming part of this place.", "The static is singing to me.", "My teeth are not my own.", "The walls are breathing, can't you feel it?", "My reflection has a different face.", "The whispers are getting louder."], normal: ["You aren't supposed to be here.", "The buzzing... it makes them angry.", "Follow the green light.", "Don't lose your mind. They feed on fear.", "Hurry. This place... it remembers.", "There's no escape, only deeper levels.", "The creatures here are drawn to movement.", "Don't trust the silence."], enemyResponses: { "We are one.": "I am not you.", "You cannot comprehend.": "I don't want to.", "The pattern must be completed.": "I will break it.", "Your presence is a flaw.": "I am not a flaw.", "It is listening.": "I know.", "The frequency is changing.": "I can feel it.", "You disrupt the signal.": "Good.", "Become one with the static.": "Never.", "The flesh is weak.": "But my will is strong.", "We will consume.": "Not me.", "Your form is imperfect.": "It's mine.", "Join the growth.": "I refuse." } } }
            ];
            const entityType = types[type];

            let entity;
            if (!entityType.isFriendly && zombieModel) {
                entity = THREE.SkeletonUtils.clone(zombieModel);
                entity.scale.set(0.8, 0.8, 0.8);

                const mixer = new THREE.AnimationMixer(entity);
                if (zombieAnimations && zombieAnimations.length) {
                    const clip = THREE.AnimationClip.findByName(zombieAnimations, 'walk') || zombieAnimations[0];
                    if(clip) mixer.clipAction(clip).play();
                }
                entity.userData.mixer = mixer;
                entity.position.set(x, -0.5, z);


            } else {
                const geometry = entityType.isFriendly ? new THREE.DodecahedronGeometry(entityType.size, 0) : new THREE.TorusKnotGeometry(entityType.size * 0.6, entityType.size * 0.2, 100, 16);
                const material = new THREE.MeshStandardMaterial({ color: entityType.color, emissive: entityType.emissive, emissiveIntensity: 2.0, flatShading: true, roughness: 0.8 });
                entity = new THREE.Mesh(geometry, material);
                entity.position.set(x, 0, z);
            }

            entity.castShadow = true;
            const light = new THREE.PointLight(entityType.emissive, 1.5, 15);
            entity.add(light);

            Object.assign(entity.userData, { type: type, health: entityType.health, speed: entityType.speed, baseAngle: Math.random() * Math.PI * 2, radius: 15 + Math.random() * 10, isFriendly: entityType.isFriendly, dialogue: entityType.dialogue, dialogueIndex: 0, canSpeak: true, lastSpokeTime: 0, voice: entityType.voice });

            return entity;
        }
        
        function createMorphoser() { const pC = 2000, g = new THREE.BufferGeometry(), pos = new Float32Array(pC * 3), bPos = new Float32Array(pC * 3); for (let i = 0; i < pC; i++) { const i3 = i * 3, r = Math.random() * 2.5, phi = Math.acos(2 * Math.random() - 1), theta = 2 * Math.PI * Math.random(); bPos[i3] = r * Math.sin(phi) * Math.cos(theta); bPos[i3+1] = r * Math.sin(phi) * Math.sin(theta); bPos[i3+2] = r * Math.cos(phi); } g.setAttribute('position', new THREE.BufferAttribute(pos, 3)); const m = new THREE.PointsMaterial({ color: 0xffaaff, size: 0.05, blending: THREE.AdditiveBlending, transparent: true, opacity: 0.8 }), morph = new THREE.Points(g, m); morph.userData = { basePositions: bPos, time: 0, noiseFactor: 2 }; const l = new THREE.PointLight(0xffaaff, 1.5, 20); morph.add(l); scene.add(morph); return morph; }
        function createSword() { const g = new THREE.Group(), bM = new THREE.MeshStandardMaterial({color: 0xcccccc, metalness: 0.9, roughness: 0.2}), hM = new THREE.MeshStandardMaterial({color: 0x332211, roughness: 0.8}); const b = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1.5, 0.02), bM); b.position.y = 0.75; const h = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.3), hM); const grd = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.05, 0.05), hM); grd.position.y = 0.15; g.add(b, h, grd); g.visible = false; camera.add(g); return g; }
        function createTentacle() { const g = new THREE.Group(), m = new THREE.MeshStandardMaterial({color: 0x8e44ad, roughness: 0.6, metalness: 0.2}), sG = new THREE.SphereGeometry(0.05, 8, 8); for (let i = 0; i < 15; i++) { const s = new THREE.Mesh(sG, m); s.position.y = -i * 0.1; g.add(s); } g.visible = false; camera.add(g); return g; }
        function createShotgun() { const g = new THREE.Group(), brlM = new THREE.MeshStandardMaterial({color: 0x444444, metalness: 0.8, roughness: 0.4}), stkM = new THREE.MeshStandardMaterial({color: 0x5a3a22, roughness: 0.7}); const brl = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.8, 16), brlM); brl.position.set(0, 0, -0.4); brl.rotation.x = Math.PI / 2; const stk = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.15, 0.5), stkM); stk.position.set(0, -0.05, 0.3); g.add(brl, stk); g.visible = false; camera.add(g); return g; }
        function createRailgun() { const g = new THREE.Group(), bdyM = new THREE.MeshStandardMaterial({color: 0x111111, metalness: 0.95, roughness: 0.3}), railM = new THREE.MeshStandardMaterial({color: 0x00aaff, emissive: 0x00aaff, emissiveIntensity: 2}); const bdy = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.1, 1.2), bdyM); const rG = new THREE.CylinderGeometry(0.01, 0.01, 1.0, 8); const r1 = new THREE.Mesh(rG, railM); r1.position.set(0.05, 0.03, -0.5); r1.rotation.x = Math.PI / 2; const r2 = new THREE.Mesh(rG, railM); r2.position.set(-0.05, 0.03, -0.5); r2.rotation.x = Math.PI / 2; g.add(bdy, r1, r2); g.visible = false; camera.add(g); return g; }
        function createExitPortal(level) { const g = new THREE.SphereGeometry(2, 32, 32), m = new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 2.5, transparent: true, opacity: 0.7 }), p = new THREE.Mesh(g, m); p.position.set(0, 2, 40 + level * 10); const l = new THREE.PointLight(0x00ff00, 2, 25); p.add(l); return p; }
        function createProjectile(origin, direction, color = 0xffff00, lifetime = 100, velocity = 1.2) { const g = new THREE.SphereGeometry(0.1, 8, 8), m = new THREE.MeshBasicMaterial({ color }), p = new THREE.Mesh(g, m); p.position.copy(origin); p.userData = { velocity: direction.normalize().multiplyScalar(velocity), lifetime: lifetime }; return p; }

        function setupLevel() {
            gameState.entities.forEach(e => scene.remove(e));
            gameState.entities = [];
            if (gameState.morphoser) scene.remove(gameState.morphoser);
            const hostileCount = 5 + gameState.level;
            for(let i = 0; i < hostileCount; i++) {
                const type = Math.floor(Math.random() * 3);
                const angle = (i / hostileCount) * Math.PI * 2;
                const radius = 20 + Math.random() * 20;
                gameState.entities.push(createEntity(Math.sin(angle) * radius, Math.cos(angle) * radius, type));
            }
            const friendlyAngle = Math.random() * Math.PI * 2;
            gameState.entities.push(createEntity(Math.sin(friendlyAngle) * 15, Math.cos(friendlyAngle) * 15, 3));
            gameState.entities.forEach(e => scene.add(e));
            gameState.morphoser = createMorphoser();
            gameState.morphoser.position.set((Math.random() - 0.5) * 40, 2, (Math.random() - 0.5) * 40);
        }

        function initGame() {
            gameState.chunks = {};
            updateChunks(camera.position);
            setupLevel();
            gameState.sword = createSword(); gameState.tentacle = createTentacle(); gameState.shotgun = createShotgun(); gameState.railgun = createRailgun();
            gameState.exitPortal = createExitPortal(gameState.level);
            scene.add(gameState.exitPortal);
            
            const ambientLight = new THREE.AmbientLight(0xffeecc, 0.2);
            scene.add(ambientLight);
            mainLight = new THREE.PointLight(0xffeedd, 0.8, 35);
            mainLight.position.set(0, 3, 0);
            mainLight.castShadow = true;
            camera.add(mainLight);
            scene.add(camera);
        }
        
        const events = [ { name: 'LIGHTS FLICKERING', duration: 5000, effect: () => { mainLight.intensity = 0.3 + Math.random() * 0.7; } }, { name: 'REALITY SHIFT', duration: 3000, effect: () => { scene.fog.color.setHex(Math.random() * 0xffffff); gameState.sanity -= 0.001; } }, { name: 'ENTITY SPAWN', duration: 1000, effect: () => { if(gameState.entities.filter(e => !e.isFriendly).length < 15) { const a = Math.random() * Math.PI * 2, r = 30; const nE = createEntity(camera.position.x + Math.sin(a) * r, camera.position.z + Math.cos(a) * r, Math.floor(Math.random() * 3)); gameState.entities.push(nE); scene.add(nE); } } } ];
        
        function triggerEvent() { if(!gameState.activeEvent && Math.random() < 0.3) { gameState.activeEvent = events[Math.floor(Math.random() * events.length)]; gameState.eventTimer = gameState.activeEvent.duration; document.getElementById('eventText').textContent = gameState.activeEvent.name; document.getElementById('eventText').style.opacity = 1; } }
        
        window.addEventListener('keydown', (e) => { const key = e.key.toLowerCase(); gameState.keys[key] = true; if (key === '1') switchWeapon('gun'); if (key === '2') switchWeapon('sword'); if (key === '3') switchWeapon('tentacle'); if (key === '4') switchWeapon('railgun'); if (key === '5') switchWeapon('shotgun'); if(key === 'r' && (gameState.activeWeapon === 'gun' || gameState.activeWeapon === 'shotgun') && !gameState.reloading) { AudioEngine.play('reload'); gameState.reloading = true; setTimeout(() => { if (gameState.activeWeapon === 'gun') gameState.ammo = gameState.maxAmmo; if (gameState.activeWeapon === 'shotgun') gameState.ammo = 8; gameState.reloading = false; }, 1500); } if(key === 'tab') { e.preventDefault(); gameState.shaderMode = (gameState.shaderMode + 1) % shaderModes.length; document.getElementById('shaderMode').textContent = shaderModes[gameState.shaderMode]; regenerateWorld(); } });
        window.addEventListener('keyup', (e) => { gameState.keys[e.key.toLowerCase()] = false; });
        canvas.addEventListener('click', () => { if (!AudioEngine.isInitialized) AudioEngine.init(); if(!gameState.isLocked) canvas.requestPointerLock(); else attack(); });
        document.addEventListener('pointerlockchange', () => { gameState.isLocked = document.pointerLockElement === canvas; document.body.style.cursor = gameState.isLocked ? 'none' : 'default'; });
        canvas.addEventListener('mousemove', (e) => { if(gameState.isLocked) { gameState.rotation.y -= e.movementX * 0.002; gameState.rotation.x -= e.movementY * 0.002; gameState.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, gameState.rotation.x)); } });

        function switchWeapon(weapon) { gameState.activeWeapon = weapon; if (gameState.pistol) gameState.pistol.visible = (weapon === 'gun'); gameState.sword.visible = (weapon === 'sword'); gameState.shotgun.visible = (weapon === 'shotgun'); gameState.railgun.visible = (weapon === 'railgun'); gameState.tentacle.visible = (weapon === 'tentacle'); const isGun = (weapon === 'gun' || weapon === 'shotgun' || weapon === 'railgun'); document.getElementById('ammoDisplay').style.display = isGun ? 'block' : 'none'; document.getElementById('ammoBar').style.display = isGun ? 'block' : 'none'; }
        function attack() { if (gameState.activeWeapon === 'gun') shoot(); else if (gameState.activeWeapon === 'sword') swingSword(); else if (gameState.activeWeapon === 'shotgun') shootShotgun(); else if (gameState.activeWeapon === 'railgun') shootRailgun(); else if (gameState.activeWeapon === 'tentacle') whipTentacle(); }
        function shoot() { const now = performance.now(); if(gameState.ammo > 0 && !gameState.reloading && now - gameState.lastShot > 200) { AudioEngine.play('shoot'); gameState.ammo--; gameState.lastShot = now; if (gameState.pistol) { gameState.pistol.rotation.x = -0.2; gameState.pistol.position.z = -0.4; } const d = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion); const p = createProjectile(camera.position.clone(), d); gameState.projectiles.push(p); scene.add(p); } }
        function shootShotgun() { const now = performance.now(); if(gameState.ammo >= 2 && !gameState.reloading && now - gameState.lastShot > 1000) { AudioEngine.play('shoot'); gameState.ammo -= 2; gameState.lastShot = now; for (let i = 0; i < 8; i++) { const d = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion); d.x += (Math.random() - 0.5) * 0.2; d.y += (Math.random() - 0.5) * 0.2; const p = createProjectile(camera.position.clone(), d, 0xff8800); gameState.projectiles.push(p); scene.add(p); } } }
        function shootRailgun() { const now = performance.now(); if (!gameState.reloading && now - gameState.lastShot > 2000) { AudioEngine.play('railgun'); gameState.lastShot = now; const r = new THREE.Raycaster(), d = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion); r.set(camera.position, d); const intersects = r.intersectObjects(gameState.entities); const bM = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.8 }), bG = new THREE.CylinderGeometry(0.05, 0.05, 100, 8), beam = new THREE.Mesh(bG, bM); beam.position.copy(camera.position).add(d.multiplyScalar(50)); beam.quaternion.copy(camera.quaternion); beam.rotation.x += Math.PI / 2; scene.add(beam); setTimeout(() => scene.remove(beam), 100); if (intersects.length > 0) { const hit = intersects[0].object; if (hit && hit.userData && !hit.userData.isFriendly) { hit.userData.health -= 10; AudioEngine.play('entityHit'); if (hit.userData.health <= 0) { scene.remove(hit); gameState.entities = gameState.entities.filter(e => e !== hit); gameState.kills++; if (gameState.kills === 10) { showEventText("Rifle Unlocked! Press 6 to equip."); } gameState.sanity = Math.min(1, gameState.sanity + 0.1); } } } } }
        function shootRifle() { const now = performance.now(); if(gameState.ammo > 0 && !gameState.reloading && now - gameState.lastShot > 100) { AudioEngine.play('shoot'); gameState.ammo--; gameState.lastShot = now; if (gameState.rifle) { gameState.rifle.rotation.x = -0.2; gameState.rifle.position.z = -0.4; } const d = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion); const p = createProjectile(camera.position.clone(), d, 0x00ff00, 100, 2.0); gameState.projectiles.push(p); scene.add(p); } }
        function swingSword() { if (gameState.isSwinging) return; gameState.isSwinging = true; gameState.swingStartTime = performance.now(); AudioEngine.play('swordSwing'); const f = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion); gameState.entities.forEach(e => { if (!e.userData.isFriendly && e.position.distanceTo(camera.position) < 2.5) { const d = e.position.clone().sub(camera.position).normalize(); if (f.dot(d) > 0.8) { e.userData.health -= 3; AudioEngine.play('entityHit'); if (e.userData.health <= 0) { scene.remove(e); gameState.entities = gameState.entities.filter(i => i !== e); gameState.kills++; if (gameState.kills === 10) { showEventText("Rifle Unlocked! Press 6 to equip."); } gameState.sanity = Math.min(1, gameState.sanity + 0.1); } } } }); setTimeout(() => { gameState.isSwinging = false; }, 500); }
        function whipTentacle() { if (gameState.isWhipping) return; gameState.isWhipping = true; gameState.whipStartTime = performance.now(); AudioEngine.play('tentacleWhip'); const f = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion); gameState.entities.forEach(e => { if (!e.userData.isFriendly && e.position.distanceTo(camera.position) < 4) { const d = e.position.clone().sub(camera.position).normalize(); if (f.dot(d) > 0.7) { e.userData.health -= 2; AudioEngine.play('entityHit'); if (e.userData.health <= 0) { scene.remove(e); gameState.entities = gameState.entities.filter(i => i !== e); gameState.kills++; if (gameState.kills === 10) { showEventText("Rifle Unlocked! Press 6 to equip."); } gameState.sanity = Math.min(1, gameState.sanity + 0.1); } } } }); setTimeout(() => { gameState.isWhipping = false; }, 700); }
        
        function handleConversations() {
            const now = performance.now();
            gameState.entities.forEach(entity => {
                const ud = entity.userData;
                const distToPlayer = camera.position.distanceTo(entity.position);
                if (distToPlayer < 10 && ud.canSpeak && now - ud.lastSpokeTime > 10000) {
                    if (ud.isFriendly) {
                        ud.canSpeak = false; ud.lastSpokeTime = now;
                        let dialogueSet = gameState.sanity > 0.8 ? ud.dialogue.highSanity : (gameState.sanity < 0.4 ? ud.dialogue.lowSanity : ud.dialogue.normal);
                        const line = dialogueSet[ud.dialogueIndex % dialogueSet.length];
                        const dialogueBox = document.getElementById('dialogueBox');
                        dialogueBox.textContent = line; dialogueBox.style.color = '#00eaff'; dialogueBox.style.opacity = 1;
                        AudioEngine.speakFriendly(line, () => { setTimeout(() => { dialogueBox.style.opacity = 0; ud.canSpeak = true; ud.dialogueIndex++; }, 2000); });
                    } else if (now - ud.lastSpokeTime > 20000) {
                        ud.canSpeak = false; ud.lastSpokeTime = now;
                        let dialogueSet = ud.dialogue.normal;
                        const line = dialogueSet[ud.dialogueIndex % dialogueSet.length];
                        const dialogueBox = document.getElementById('dialogueBox');
                        dialogueBox.textContent = line; dialogueBox.style.color = '#ff0000'; dialogueBox.style.opacity = 1;
                        AudioEngine.speakEnemy(line, () => { setTimeout(() => { dialogueBox.style.opacity = 0; ud.canSpeak = true; ud.dialogueIndex++; dialogueBox.style.color = '#00eaff'; }, 2000); });
                    }
                }
            });
            const friendlies = gameState.entities.filter(e => e.userData.isFriendly), hostiles = gameState.entities.filter(e => !e.userData.isFriendly);
            friendlies.forEach(friendly => {
                hostiles.forEach(hostile => {
                    const dist = friendly.position.distanceTo(hostile.position);
                    if (dist < 15 && friendly.userData.canSpeak && hostile.userData.canSpeak && now - friendly.userData.lastSpokeTime > 15000 && now - hostile.userData.lastSpokeTime > 15000) {
                        friendly.userData.canSpeak = false; hostile.userData.canSpeak = false; friendly.userData.lastSpokeTime = now; hostile.userData.lastSpokeTime = now;
                        const hostileDialogueSet = hostile.userData.dialogue.normal, hostileLine = hostileDialogueSet[hostile.userData.dialogueIndex % hostileDialogueSet.length];
                        hostile.userData.dialogueIndex++;
                        const friendlyResponse = friendly.userData.dialogue.enemyResponses[hostileLine] || "What are you talking about?";
                        const dialogueBox = document.getElementById('dialogueBox');
                        setTimeout(() => { dialogueBox.textContent = hostileLine; dialogueBox.style.color = '#ff0000'; dialogueBox.style.opacity = 1; AudioEngine.speakEnemy(hostileLine); }, 0);
                        setTimeout(() => { dialogueBox.textContent = friendlyResponse; dialogueBox.style.color = '#00eaff'; dialogueBox.style.opacity = 1; AudioEngine.speakFriendly(friendlyResponse); }, 3000);
                        setTimeout(() => { dialogueBox.style.opacity = 0; friendly.userData.canSpeak = true; hostile.userData.canSpeak = true; }, 6000);
                    }
                });
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001;
            const delta = time - (gameState.lastTime || time);
            gameState.lastTime = time;

            if (sky && sky.material && sky.material.uniforms && sky.material.uniforms.time) { sky.material.uniforms.time.value = time; if (sky.material.uniforms.speed) sky.material.uniforms.speed.value = 0.25; }
            if (gameState.sanity < 0.25 && gameState.shaderMode !== 4) { gameState.shaderMode = 4; document.getElementById('shaderMode').textContent = shaderModes[gameState.shaderMode]; regenerateWorld(); } else if (gameState.sanity >= 0.25 && gameState.shaderMode === 4) { gameState.shaderMode = 0; document.getElementById('shaderMode').textContent = shaderModes[gameState.shaderMode]; regenerateWorld(); }

            Object.values(gameState.chunks).forEach(chunk => { chunk.traverse(child => { if (child.material && child.material.uniforms) { if (child.material.uniforms.time) child.material.uniforms.time.value = time; if (child.material.uniforms.sanity) child.material.uniforms.sanity.value = gameState.sanity; } }); });

            updateChunks(camera.position);
            Object.values(gameState.chunks).forEach(chunk => { if (chunk.userData && chunk.userData.collectibles) { chunk.userData.collectibles.forEach((orb, idx) => { if (!orb || orb.userData.collected) return; const d = orb.position.distanceTo(camera.position.clone().sub(chunk.position)); if (d < 2.0) { orb.userData.collected = true; AudioEngine.play('pickup'); gameState.collected++; document.getElementById('collected').textContent = gameState.collected; if (orb.parent) orb.parent.remove(orb); if (orb.geometry) orb.geometry.dispose(); if (orb.material) orb.material.dispose(); } }); chunk.userData.collectibles = chunk.userData.collectibles.filter(o => o && !o.userData.collected); } });
            gameState.flickeringLights.forEach(light => { if (Math.random() > 0.95) light.intensity = Math.random() * 1.5; });
            
            camera.rotation.order = 'YXZ'; camera.rotation.y = gameState.rotation.y; camera.rotation.x = gameState.rotation.x;
            
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion), right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion), moveDirection = new THREE.Vector3();
            if(gameState.keys['w']) moveDirection.add(forward); if(gameState.keys['s']) moveDirection.sub(forward); if(gameState.keys['a']) moveDirection.sub(right); if(gameState.keys['d']) moveDirection.add(right);
            if (moveDirection.length() > 0) { const bobHeight = Math.cos(time * 8) * 0.03; camera.position.y = 1.6 + bobHeight; camera.position.add(moveDirection.normalize().multiplyScalar(gameState.moveSpeed)); if (performance.now() - gameState.lastStepTime > 400) { AudioEngine.play('walk'); gameState.lastStepTime = performance.now(); } }

            const isMoving = moveDirection.length() > 0.01;
            if (gameState.pistol && gameState.pistol.visible) { const bobAngle = Math.sin(time * 2) * 0.02, bobHeight = isMoving ? Math.cos(time * 8) * 0.02 : 0; gameState.pistol.rotation.z = bobAngle; gameState.pistol.position.y = -0.3 + bobHeight; gameState.pistol.rotation.x = THREE.MathUtils.lerp(gameState.pistol.rotation.x, 0, 0.1); gameState.pistol.position.z = THREE.MathUtils.lerp(gameState.pistol.position.z, -0.5, 0.1); }
            if (gameState.sword && gameState.sword.visible) { const swingProgress = gameState.isSwinging ? (performance.now() - gameState.swingStartTime) / 500 : 0; gameState.sword.position.set(0.4, -0.4, -0.8); if (gameState.isSwinging) { const swingAngle = Math.sin(Math.min(swingProgress, 1) * Math.PI); gameState.sword.rotation.set(0, -swingAngle * 2, swingAngle * 0.5); } else { const bobAngle = Math.sin(time * 2) * 0.05, bobHeight = isMoving ? Math.cos(time * 8) * 0.05 : 0; gameState.sword.rotation.set(0, 0, bobAngle); gameState.sword.position.y = -0.4 + bobHeight; } }
            if (gameState.tentacle && gameState.tentacle.visible) { const whipProgress = gameState.isWhipping ? (performance.now() - gameState.whipStartTime) / 700 : 0; gameState.tentacle.position.set(0.5, -0.7, -1.2); gameState.tentacle.rotation.z = Math.sin(time * 5) * 0.2; gameState.tentacle.children.forEach((segment, i) => { const angle = Math.sin(i * 0.5 + time * 10) * 0.3; segment.position.x = Math.sin(i * 0.5 + time * 5) * i * 0.05; segment.rotation.z = angle; if(gameState.isWhipping) { const whipAngle = Math.sin(Math.min(whipProgress, 1) * Math.PI); segment.position.x += Math.sin(i * 0.5 + whipProgress * 10) * 0.5; segment.position.z = Math.cos(i * 0.5 + whipProgress * 10) * 0.5; } }); }
            
            for(let i = gameState.projectiles.length - 1; i >= 0; i--) { const proj = gameState.projectiles[i]; proj.position.add(proj.userData.velocity); proj.userData.lifetime--; if(proj.userData.lifetime <= 0) { scene.remove(proj); gameState.projectiles.splice(i, 1); continue; } for(let j = gameState.entities.length - 1; j >= 0; j--) { const entity = gameState.entities[j]; if (!entity.userData.isFriendly && proj.position.distanceTo(entity.position) < 1.5) { entity.userData.health--; AudioEngine.play('entityHit'); scene.remove(proj); gameState.projectiles.splice(i, 1); if(entity.userData.health <= 0) { scene.remove(entity); gameState.entities.splice(j, 1); gameState.kills++; if (gameState.kills === 10) { showEventText("Rifle Unlocked! Press 6 to equip."); } gameState.sanity = Math.min(1, gameState.sanity + 0.1); } break; } } }
            
            let closestHostileDist = 1000;
            gameState.entities.forEach(entity => {
                if (entity.userData.mixer) entity.userData.mixer.update(delta);
                if (!entity.userData.isFriendly) {
                    const dist = entity.position.distanceTo(camera.position);
                    if (dist < closestHostileDist) closestHostileDist = dist;
                    entity.lookAt(camera.position);
                    entity.rotateY(Math.PI);
                    if (dist > 2) entity.translateZ(entity.userData.speed);
                }
            });

            handleConversations();

            if (gameState.morphoser) { gameState.morphoser.userData.time += delta * 0.5; const pos = gameState.morphoser.geometry.attributes.position.array, bPos = gameState.morphoser.userData.basePositions; for (let i = 0; i < pos.length; i+=3) { pos[i] = bPos[i] + Math.sin(gameState.morphoser.userData.time + bPos[i+1]) * 0.5; pos[i+1] = bPos[i+1] + Math.cos(gameState.morphoser.userData.time + bPos[i+2]) * 0.5; pos[i+2] = bPos[i+2] + Math.sin(gameState.morphoser.userData.time + bPos[i]) * 0.5; } gameState.morphoser.geometry.attributes.position.needsUpdate = true; const distToMorphoser = camera.position.distanceTo(gameState.morphoser.position); if (distToMorphoser < 15 && forward.dot(gameState.morphoser.position.clone().sub(camera.position).normalize()) > 0.7) { gameState.sanity -= 0.002 * (1 - distToMorphoser / 15); } }
            
            const warning = document.getElementById('warning');
            if(closestHostileDist < 25) { gameState.sanity -= 0.0008; warning.style.opacity = Math.max(0, 1 - closestHostileDist / 25); } else { warning.style.opacity = 0; }
            if(closestHostileDist < 3) gameState.sanity -= 0.015;
            
            gameState.sanity = Math.max(0, Math.min(1, gameState.sanity + 0.0001));
            AudioEngine.updateSanityEffect(gameState.sanity);
            
            if(gameState.eventTimer > 0) { gameState.eventTimer -= 16; if(gameState.activeEvent) gameState.activeEvent.effect(); if(gameState.eventTimer <= 0) { gameState.activeEvent = null; scene.fog.color.setHex(0x0a0a0a); mainLight.intensity = 0.8; document.getElementById('eventText').style.opacity = 0; } } else if(Math.random() < 0.001) { triggerEvent(); }
            
            if(camera.position.distanceTo(gameState.exitPortal.position) < 5) { AudioEngine.play('nextLevel'); gameState.level++; camera.position.set(0, 1.6, 0); scene.remove(gameState.exitPortal); gameState.exitPortal = createExitPortal(gameState.level); scene.add(gameState.exitPortal); setupLevel(); }

            document.getElementById('sanity').textContent = (gameState.sanity * 100).toFixed(0);
            document.getElementById('level').textContent = gameState.level;
            document.getElementById('kills').textContent = gameState.kills;
            document.getElementById('ammo').textContent = gameState.reloading ? 'RELOADING' : `${gameState.ammo} / âˆž`;
            document.getElementById('ammoFill').style.width = `${gameState.reloading ? 0 : (gameState.ammo / gameState.maxAmmo) * 100}%`;

            composer.render();
        }

        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight); });

      }
    </script>
</body>
</html>