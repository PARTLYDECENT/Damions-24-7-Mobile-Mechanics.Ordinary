<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Backrooms Escape</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', monospace;
        }
        
        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #ffff00;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 10;
            pointer-events: none;
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.7);
            border-radius: 50%;
            pointer-events: none;
            z-index: 5;
        }
        
        #crosshair::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
        }
        
        #instructions {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.6);
            font-size: 14px;
            text-align: center;
            z-index: 10;
            pointer-events: none;
        }
        
        #warning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff0000;
            font-size: 48px;
            text-align: center;
            opacity: 0;
            text-shadow: 0 0 20px #ff0000;
            z-index: 15;
            pointer-events: none;
        }
        
        .scanline {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.1),
                rgba(0, 0, 0, 0.1) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 20;
            opacity: 0.3;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="scanline"></div>
    <div id="crosshair"></div>
    
    <div id="ui">
        <div>SANITY: <span id="sanity">100</span>%</div>
        <div>LEVEL: <span id="level">0</span></div>
        <div>ENTITIES NEARBY: <span id="entities">0</span></div>
    </div>
    
    <div id="instructions">
        WASD - Move | MOUSE - Look | CLICK to lock cursor | Find the EXIT
    </div>
    
    <div id="warning">THEY ARE COMING</div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const canvas = document.getElementById('canvas');
        
        // Scene setup
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x9c8f6f, 1, 50);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 1.6, 0);
        
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        
        // Game state
        let gameState = {
            sanity: 1.0,
            level: 0,
            moveSpeed: 0.1,
            entities: [],
            exitPortal: null,
            keys: {},
            mouseX: 0,
            mouseY: 0,
            rotation: { x: 0, y: 0 },
            isLocked: false
        };
        
        // Custom shader material for walls
        const wallShader = {
            uniforms: {
                time: { value: 0 },
                sanity: { value: 1.0 }
            },
            vertexShader: `
                varying vec2 vUv;
                varying vec3 vPos;
                void main() {
                    vUv = uv;
                    vPos = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                uniform float sanity;
                varying vec2 vUv;
                varying vec3 vPos;
                
                float random(vec2 st) {
                    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
                }
                
                float noise(vec2 st) {
                    vec2 i = floor(st);
                    vec2 f = fract(st);
                    float a = random(i);
                    float b = random(i + vec2(1.0, 0.0));
                    float c = random(i + vec2(0.0, 1.0));
                    float d = random(i + vec2(1.0, 1.0));
                    vec2 u = f * f * (3.0 - 2.0 * f);
                    return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
                }
                
                void main() {
                    vec3 color = vec3(0.8, 0.75, 0.5);
                    
                    float n = noise(vUv * 20.0 + time * 0.1);
                    color *= 0.7 + n * 0.3;
                    
                    float distort = sin(vPos.x * 2.0 + time) * sin(vPos.z * 2.0 + time * 0.7) * (1.0 - sanity) * 0.3;
                    color += vec3(1.0, 0.0, 0.0) * distort;
                    
                    float darkening = 1.0 - (1.0 - sanity) * 0.5;
                    color *= darkening;
                    
                    gl_FragColor = vec4(color, 1.0);
                }
            `
        };
        
        // Create procedural maze
        function createMaze() {
            const group = new THREE.Group();
            const wallMaterial = new THREE.ShaderMaterial(wallShader);
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8b7d5f,
                roughness: 0.9
            });
            
            // Floor
            const floorGeo = new THREE.PlaneGeometry(200, 200);
            const floor = new THREE.Mesh(floorGeo, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            group.add(floor);
            
            // Ceiling
            const ceiling = new THREE.Mesh(floorGeo, floorMaterial);
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.y = 4;
            group.add(ceiling);
            
            // Create maze walls
            const wallGeo = new THREE.BoxGeometry(1, 4, 8);
            for(let x = -50; x < 50; x += 8) {
                for(let z = -50; z < 50; z += 8) {
                    if(Math.random() > 0.3) {
                        const wall = new THREE.Mesh(wallGeo, wallMaterial);
                        wall.position.set(x + 4, 2, z);
                        wall.castShadow = true;
                        group.add(wall);
                    }
                    if(Math.random() > 0.3) {
                        const wall2 = new THREE.Mesh(new THREE.BoxGeometry(8, 4, 1), wallMaterial);
                        wall2.position.set(x, 2, z + 4);
                        wall2.castShadow = true;
                        group.add(wall2);
                    }
                }
            }
            
            // Pillars
            const pillarGeo = new THREE.BoxGeometry(0.5, 4, 0.5);
            for(let x = -40; x < 40; x += 16) {
                for(let z = -40; z < 40; z += 16) {
                    const pillar = new THREE.Mesh(pillarGeo, wallMaterial);
                    pillar.position.set(x, 2, z);
                    pillar.castShadow = true;
                    group.add(pillar);
                }
            }
            
            return group;
        }
        
        // Create entities
        function createEntity(x, z) {
            const geometry = new THREE.SphereGeometry(0.8, 16, 16);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0x330000,
                emissive: 0xff0000,
                emissiveIntensity: 0.5
            });
            const entity = new THREE.Mesh(geometry, material);
            entity.position.set(x, 1.5, z);
            entity.castShadow = true;
            
            const light = new THREE.PointLight(0xff0000, 0.5, 10);
            entity.add(light);
            
            return entity;
        }
        
        // Create exit portal
        function createExitPortal(level) {
            const geometry = new THREE.SphereGeometry(2, 32, 32);
            const material = new THREE.MeshStandardMaterial({
                color: 0x00ff00,
                emissive: 0x00ff00,
                emissiveIntensity: 1,
                transparent: true,
                opacity: 0.6
            });
            const portal = new THREE.Mesh(geometry, material);
            portal.position.set(0, 2, 40 + level * 20);
            
            const light = new THREE.PointLight(0x00ff00, 2, 20);
            portal.add(light);
            
            return portal;
        }
        
        // Initialize scene
        const maze = createMaze();
        scene.add(maze);
        
        gameState.entities.push(createEntity(10, 10));
        gameState.entities.push(createEntity(-15, 15));
        gameState.entities.forEach(e => scene.add(e));
        
        gameState.exitPortal = createExitPortal(gameState.level);
        scene.add(gameState.exitPortal);
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0x9c8f6f, 0.4);
        scene.add(ambientLight);
        
        const mainLight = new THREE.PointLight(0xffffff, 0.8, 30);
        mainLight.position.set(0, 3, 0);
        mainLight.castShadow = true;
        camera.add(mainLight);
        scene.add(camera);
        
        // Input handling
        window.addEventListener('keydown', (e) => {
            gameState.keys[e.key.toLowerCase()] = true;
        });
        
        window.addEventListener('keyup', (e) => {
            gameState.keys[e.key.toLowerCase()] = false;
        });
        
        canvas.addEventListener('click', () => {
            canvas.requestPointerLock();
        });
        
        document.addEventListener('pointerlockchange', () => {
            gameState.isLocked = document.pointerLockElement === canvas;
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if(gameState.isLocked) {
                gameState.rotation.y -= e.movementX * 0.002;
                gameState.rotation.x -= e.movementY * 0.002;
                gameState.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, gameState.rotation.x));
            }
        });
        
        // Game loop
        function animate() {
            requestAnimationFrame(animate);
            
            const time = performance.now() * 0.001;
            
            // Update shader
            maze.children.forEach(child => {
                if(child.material && child.material.uniforms) {
                    child.material.uniforms.time.value = time;
                    child.material.uniforms.sanity.value = gameState.sanity;
                }
            });
            
            // Camera rotation
            camera.rotation.order = 'YXZ';
            camera.rotation.y = gameState.rotation.y;
            camera.rotation.x = gameState.rotation.x;
            
            // Movement
            const forward = new THREE.Vector3(
                Math.sin(gameState.rotation.y),
                0,
                Math.cos(gameState.rotation.y)
            );
            const right = new THREE.Vector3(
                Math.cos(gameState.rotation.y),
                0,
                -Math.sin(gameState.rotation.y)
            );
            
            if(gameState.keys['w']) camera.position.add(forward.multiplyScalar(gameState.moveSpeed));
            if(gameState.keys['s']) camera.position.add(forward.multiplyScalar(-gameState.moveSpeed));
            if(gameState.keys['a']) camera.position.add(right.multiplyScalar(-gameState.moveSpeed));
            if(gameState.keys['d']) camera.position.add(right.multiplyScalar(gameState.moveSpeed));
            
            camera.position.y = 1.6;
            
            // Update entities
            gameState.entities.forEach((entity, i) => {
                entity.position.y = 1.5 + Math.sin(time * 2 + i) * 0.3;
                entity.rotation.y += 0.02;
                
                const angle = time * 0.3 + i * Math.PI;
                const radius = 15;
                entity.position.x = Math.sin(angle) * radius;
                entity.position.z = Math.cos(angle) * radius;
            });
            
            // Check entity distance
            let closestDist = 1000;
            gameState.entities.forEach(entity => {
                const dist = camera.position.distanceTo(entity.position);
                closestDist = Math.min(closestDist, dist);
            });
            
            if(closestDist < 20) {
                gameState.sanity -= 0.0005;
                const warning = document.getElementById('warning');
                warning.style.opacity = Math.max(0, 1 - closestDist / 20);
            } else {
                document.getElementById('warning').style.opacity = 0;
            }
            
            if(closestDist < 3) {
                gameState.sanity -= 0.01;
            }
            
            gameState.sanity = Math.max(0, Math.min(1, gameState.sanity));
            
            // Check exit
            const exitDist = camera.position.distanceTo(gameState.exitPortal.position);
            if(exitDist < 5) {
                gameState.level++;
                camera.position.set(0, 1.6, 0);
                scene.remove(gameState.exitPortal);
                gameState.exitPortal = createExitPortal(gameState.level);
                scene.add(gameState.exitPortal);
                gameState.sanity = Math.min(1, gameState.sanity + 0.3);
            }
            
            // Update UI
            document.getElementById('sanity').textContent = Math.floor(gameState.sanity * 100);
            document.getElementById('level').textContent = gameState.level;
            document.getElementById('entities').textContent = closestDist < 30 ? 2 : 0;
            
            if(gameState.sanity <= 0) {
                document.getElementById('warning').textContent = 'YOU ARE LOST FOREVER';
                document.getElementById('warning').style.opacity = 1;
            }
            
            renderer.render(scene, camera);
        }
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        animate();
    </script>
</body>
</html>